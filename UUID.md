# Code analysis

```
def uuid1(node=None, clock_seq=None):
    global timetime
    """Generate a UUID from a host ID, sequence number, and the current time.
    If 'node' is not given, getnode() is used to obtain the hardware
    address.  If 'clock_seq' is given, it is used as the sequence number;
    otherwise a random 14-bit sequence number is chosen."""

    # When the system provides a version-1 UUID generator, use it (but don't
    # use UuidCreate here because its UUIDs don't conform to RFC 4122).
    if _generate_time_safe is not None and node is clock_seq is None:
        uuid_time, safely_generated = _generate_time_safe()
        try:
            is_safe = SafeUUID(safely_generated)
        except ValueError:
            is_safe = SafeUUID.unknown
        return UUID(bytes=uuid_time, is_safe=is_safe)

    global _last_timestamp
    import time
    nanoseconds = time.time_ns()
    # 0x01b21dd213814000 is the number of 100-ns intervals between the
    # UUID epoch 1582-10-15 00:00:00 and the Unix epoch 1970-01-01 00:00:00.
    timestamp = nanoseconds // 100 + 0x01b21dd213814000
    if _last_timestamp is not None and timestamp <= _last_timestamp:
        timestamp = _last_timestamp + 1
    _last_timestamp = timestamp
    if clock_seq is None:
        import random
        clock_seq = random.getrandbits(14) # instead of stable storage
    time_low = timestamp & 0xffffffff
    time_mid = (timestamp >> 32) & 0xffff
    time_hi_version = (timestamp >> 48) & 0x0fff
    clock_seq_low = clock_seq & 0xff
    clock_seq_hi_variant = (clock_seq >> 8) & 0x3f
    if node is None:
        node = getnode()
    return UUID(fields=(time_low, time_mid, time_hi_version,
                        clock_seq_hi_variant, clock_seq_low, node), version=1)
```

If the `clock_seq` attribute is known by attackers, they could just simply launch a "sandwhich attack" to predict the next UUID generated.(reference: https://book.hacktricks.wiki/zh/pentesting-web/uuid-insecurities.html)

The logic of generating clock_seq:

```
    if clock_seq is None:
        import random
        clock_seq = random.getrandbits(14) # instead of stable storage
```

as we can see, the `clock_seq` attribute is actually generated by `random.getrandbits(14)` which is not a secure method to generate random bits because the random bits generated by MT19937 algorithm could be predicted when attackers have got 624*32 bits.

Simply put, when the attacker can get 624*32//14+1 UUIDs, they could launch a "sandwhich attack" to predict the next UUID generated.

to extract the random bits generated we can use:

```
def extract_clock_seq(uuid_val):
	# RFC 4122
    clock_seq_hi = uuid_val.fields[3]  # clock_seq_hi_variant (8 bits)
    clock_seq_low = uuid_val.fields[4]  # clock_seq_low (8 bits)
    return ((clock_seq_hi & 0x3f) << 8) | clock_seq_low

uuids = [uuid.uuid1() for _ in range(1427)]
clock_seqs = [extract_clock_seq(u) for u in uuids] # This is a list of random bits
```

and we could reconstruct the generater by using `pyrandcracker`.

https://github.com/guoql666/pyrandcracker

and finally we could predict the clock_seq of the next UUID

*NOTE: uuid6() is also effected as the logic of generating `clock_seq` remains the same.*
